---
title: "The evolution of diverse antimicrobial responses in
vancomycin-intermediate Staphylococcus aureus and its therapeutic implications"
author: Kyle Card and Arda Durmaz
Date: 1/8/2025
output: html_notebook
---

## Prerequisites

Clear current environment

```{r Clear current environment, include = FALSE}
rm(list = ls())
```
<br>

Load packages

```{r Packages, message = FALSE}
library(tidyverse)
library(magick)
library(pdftools)
library(grid)
library(cowplot)
library(proxy)
library(foreach)
library(doParallel)
library(MASS)
library(glmnet)
library(pheatmap)
library(BayesLCA)
```
<br>

```{r Suppress summarise info}
options(dplyr.summarise.inform = FALSE)
```
<br>

***

# Experimental evolution under vancomycin selection

Load data

```{r Vancomycin MIC data}
# Data report the minimum inhibitory concentrations (MICs) of the 18
# experimental populations evolved under increasing vancomycin concentrations
# until they reach intermediate resistance levels (4 - 8 ug/mL).
vancomycin_MICs <- read_csv("data/vancomycin_MICs.csv",
  show_col_types = FALSE
)
```
<br>

```{r Function that plots vancomycin MIC data, messages = FALSE}
generate_vanc_plot <- function(.x) {
  # In the MIC column, replace all "-" with "NA"
  .x$MIC <- .x$MIC %>%
    str_replace_all("-", "NA") %>%
    as.numeric()

  # Remove all rows with NA values in the MIC column
  .x <- .x %>%
    filter(!is.na(MIC))

  # Plot of vancomycin MICs over time
  vanc_plot <- .x %>%
    ggplot(aes(
      x = day,
      y = MIC
    )) +
    geom_rect(
      aes(
        xmin = -Inf,
        xmax = Inf,
        ymin = 4,
        ymax = 8
      ),
      fill = "#E1EEF4",
      alpha = 0.1
    ) +
    geom_line(linewidth = 1.2) +
    geom_point(size = 2) +
    facet_wrap(~population,
      nrow = 3,
      ncol = 6
    ) +
    scale_x_continuous(breaks = seq(1, 14, 2)) +
    scale_y_continuous(
      limits = c(0, 8),
      breaks = seq(0, 8, 2)
    ) +
    xlab("Day") +
    ylab(expression("MIC (\u03BCg/mL)")) +
    theme_cowplot() +
    theme(panel.grid.major = element_line(
      color = "#3a3a3a",
      linewidth = 0.2
    )) +
    theme(plot.background = element_rect(fill = "#FFFFFF"))

  # Combine the experimental schematic illustration and vancomycin plot
  # Imports PDF experimental schema image into R and adds it above the
  # vancomycin_MICs_plot
  schema <- image_read_pdf("Figures/experimental_schema.pdf",
    density = 300
  )

  schema_grob <- rasterGrob(as.raster(schema),
    interpolate = TRUE
  )

  combined_plot <- plot_grid(schema_grob,
    vanc_plot,
    ncol = 1,
    rel_heights = c(0.3, 0.7),
    labels = c("A", "B"),
    label_size = 16
  )

  combined_plot <- combined_plot +
    theme(plot.background = element_rect(fill = "#FFFFFF"))

  return(combined_plot)
}
```
<br>

```{r Generate plot with experimental schema and vancomycin MIC data}
schema_vanc_plot <- generate_vanc_plot(vancomycin_MICs)

schema_vanc_plot
```
<br>

```{r Save plot of vancomycin MIC data with experimental schema}
ggsave("figure_1.tiff",
  schema_vanc_plot,
  path = "Figures",
  device = "tiff",
  width = 12,
  height = 8,
  units = "in"
)
```
<br>

***

# Genomic evolution

We used the *breseq* pipeline (v0.39.0) to identify mutations in the control and
treated populations. The control lines evolved in TSB medium without vancomycin,
whereas the treated lines evolved in TSB medium supplemented with vancomycin.
We concatenated the *breseq* output files for each control and treated
population, labeled "C1" through "C87" and "T1" through "T18", respectively.
We also manually curated the *breseq* output files to ensure that the mutations
were correctly identified and annotated. Lastly, following Deatherage et al.
2017 and Card et al. 2021, for each mutation, we determined whether it
"qualified" for further analyses based on the following criteria:

1. It was a nonsynonymous point mutation or small indel in a single gene.
2. An intergenic mutation within 150 bp upstream of the start of a gene.
3. A large deletion if at least one of the affected genes was also found
to be mutated in another population.

Conversely, we excluded mutations from further analyses if they were:

1. Synonymous (does not affect the resulting amino acid sequence).
2. Multicopy elements (e.g., ribosomal RNA operons) that may result from
gene conversions but cannot be fully resolved using short-read sequencing data.

We also include all mutations that were at or above 5% frequency in the
populations given that each population had an average read coverage depth of
>100X. A total of *227* mutations qualify based upon these criteria in the
vancomycin-evolved lines and *3585* mutations qualify in the control lines.

```{r Reads in mutation data, messages = FALSE}
mutations <- read_csv("data/mutations.csv",
  show_col_types = FALSE
)

# Filter the mutations object by the presence of qualifying mutations.
qualifying_mutations <- mutations %>%
  filter(qualifying_mutation == "yes")
```
<br>

The following code:

1. Generates a binary matrix representing the qualifying gene-level mutations
in each evolutionary replicate. We use this matrix for subsequent analyses.
2. Calculates the average pairwise similarity within the vancomycin-adapted
lines and the control lines. We then compare the average similarity between
the two groups to determine if the vancomycin-adapted lines exhibit a higher
degree of genomic parallelism than the control lines.
3. Performs a bootstrap analysis to evaluate the statistical significance of
the observed difference between the vancomycin-adapted and control lines.

---

We quantified the extent of genomic parallelism in the vancomycin-adapted lines
and in the control lines by calculating Dice's Similarity Coefficient (*S*)
for each population pair, where:

$$S = \frac{2|X \cap Y|}{|X|+|Y|}$$

$|X|$ and $|Y|$ represent the number of genes with qualifying mutations in each
population, and $|X \cap Y|$ is the number of mutated genes in common between
them. *S* therefore ranges from 0, when the pair share no mutations in common,
to 1, when both have mutations in exactly the same set of genes
(Deatherage et al., 2017; Card et al. 2021).

By default, the perform_genomic_analysis function will output a list containing
two elements:

1. Average pairwise similarity within the vancomycin-treated group
($\overline{S}_v \approx 0.0625$) and within the control group
($\overline{S}_c \approx 0.0290$). In other words, two populations that
independently evolved under vancomycin selection had, on average, *6.25%* of
their mutated genes in common, whereas those that evolved under identical
conditions, but without vancomycin, shared on average only *2.90%* of their
mutated genes.

2. The difference between these averages
($\overline{S}_v - \overline{S}_c \approx 0.0335$) represents how much greater
(on average) the vancomycin-adapted lines' similarity is relative to the control
lines. We expect that the vancomycin-adapted lines will exhibit a higher degree
of genomic parallelism than the control lines.

---

To evaluate the statistical significance of the observed difference between
the vancomycin-adapted and control lines, we generated a bootstrap distribution
assuming no difference between the two groups. We pooled all data into one
combined dataset, then repeatedly sampled (with replacement) two new subsets of
the same sizes as the original groups. For each bootstrap iteration
(10,000 total), we calculated the difference in mean similarities between the
subsets. We then compared our observed difference to the distribution of
differences generated by the bootstrap analysis. The *p*-value is the proportion
of bootstrap iterations where the difference was greater than or equal to the
observed difference.

```{r Generation of binary data frame of mutations}
generate_binary_matrix <- function(.x) {
  # Creates a vector of the unique sample designations in the
  # qualifying_mutations object
  populations <- unique(.x$population)

  # Sorts the genes with qualifying_mutations by number of hits and
  # creates a vector
  genes <- .x %>%
    group_by(gene) %>%
    summarize(hits = n()) %>%
    arrange(desc(hits)) %>%
    pull(gene)

  # Creates a binary matrix with the number of rows equal to the number of
  # samples, and the number of columns equal to the number of genes in the
  # mutations object and populates the matrix with 0s.
  binary_mat <- matrix(0,
    nrow = length(populations),
    ncol = length(genes)
  )

  rownames(binary_mat) <- populations
  colnames(binary_mat) <- genes

  # Use the qualifying_mutations object to populate the binary_mat object.
  # This code chunk iterates through the qualifying mutations data frame
  # and populates the binary_mat object with a 1 if a mutation is present in a
  # given gene / lineage combination
  for (i in seq_len(nrow(.x))) {
    binary_mat[.x$population[i], .x$gene[i]] <- 1
  }

  return(binary_mat)
}
```
<br>

```{r Generate binary matrix}
binary_matrix <- generate_binary_matrix(qualifying_mutations)
```
<br>

```{r Similarity and bootstrap function}
perform_genomic_analysis <- function(.x, iterations = 10000) {
  calculate_similarity <- function(.x, bootstrap = FALSE) {
    if (bootstrap == TRUE) {
      # Sample the lines, with replacement, 105 times.
      .x <- .x[sample(nrow(.x), replace = TRUE), ]

      # Rename the rows of the sampled dataset - some rows are sampled
      # more than once. By default R will append a number to the end of the
      # row name to ensure unique names. These rows are then treated separately
      # in the downstream analyses. This code chunk renames the rows to
      # C1, C2, ..., C87 and T1, T2, ..., T18 etc to avoid this issue.
      rownames(.x) <- c(paste0("C", 1:87), paste0("T", 1:18))
    }

    # Computes Dice's Similarity Coefficient for all possible replicate pairs.
    # Populates a matrix with these values.
    pwise_simil_matrix <- as.matrix(
      simil(.x,
        method = "Dice",
        by_rows = TRUE,
        upper = TRUE,
        diag = TRUE
      )
    )

    # All values above (and including) the matrix diagonal are converted to
    # NA to ease downstream wrangling.
    diag(pwise_simil_matrix) <- NA
    pwise_simil_matrix[upper.tri(pwise_simil_matrix)] <- NA

    # Converted matrix to a data frame for analysis. NA values above
    # (and including) the matrix diagonal are incorporated into the newly
    # formed data frame. This piece of code drops the rows containing NA,
    # effectively retaining only those values *below* the matrix diagonal.
    pwise_simil_df <- as.data.frame.table(pwise_simil_matrix,
      responseName = "value"
    ) %>%
      rename(
        population_1 = Var1,
        population_2 = Var2
      ) %>%
      drop_na() %>%
      # Remove numbers at the end of the population names
      mutate(
        population_1 = str_remove_all(population_1, "\\d"),
        population_2 = str_remove_all(population_2, "\\d")
      )


    ## First part of the summary output ##

    # Computes the mean pairwise similarity within the vancomycin group
    # and control group.
    avg_similarity_df <- pwise_simil_df %>%
      group_by(population_1, population_2) %>%
      summarize(avg = mean(value)) %>%
      as_tibble() %>%
      filter(population_1 == population_2)


    ## Second part of the summary output ##

    difference <- avg_similarity_df[2, 3] - avg_similarity_df[1, 3]
    names(difference) <- "difference"

    # When the bootstrap argument is FALSE, then the calculate_similarity
    # function returns a list containing the *observed* mean pairwise
    # similarity within the vancomycin-adapted and control lines, and the
    # difference between these two values.

    # When the bootstrap argument is TRUE, then the calculate_similarity
    # function returns a data frame containing the *bootstrap* mean pairwise
    # similarity within the vancomycin-adapted and control lines, and the
    # difference between these two values.
    if (bootstrap == FALSE) {
      results <- list(avg_similarity_df, difference)
    } else {
      # Makes a data frame with three columns:
      # 1. Bootstrap average pairwise similarity - control populations
      # 2. Bootstrap average pairwise similarity - experimental populations
      # 3. Difference between these bootstrap means
      results <- avg_similarity_df %>%
        mutate(treatment = ifelse(population_1 == "C",
          yes = "control",
          no = "experimental"
        )) %>%
        select(-population_1, -population_2) %>%
        pivot_wider(
          names_from = treatment,
          values_from = avg
        ) %>%
        mutate(difference = experimental - control)
    }

    return(results)
  }

  # Function to perform bootstrap analysis
  perform_bootstrap_analysis <- function(.x, iterations) {
    # Detect number of cores and register parallel backend
    cl <- makeCluster(detectCores() - 1)
    registerDoParallel(cl)

    # Bootstrap distributions of the average pairwise similarity in
    # each treatment
    results <- foreach(
      i = 1:iterations,
      .combine = rbind,
      .packages = c("tidyverse", "proxy"),
      .export = "calculate_similarity"
    ) %dopar% {
      calculate_similarity(.x, bootstrap = TRUE)
    }

    stopCluster(cl)

    return(results)
  }

  # Calculate *observed* average pairwise similarity within the
  # vancomycin-adapted and control lines
  similarity <- calculate_similarity(.x)

  # Perform bootstrap analysis
  bootstrap_results <- perform_bootstrap_analysis(.x, iterations)

  # Calculate significance
  significance <- sum(
    bootstrap_results$difference >= similarity[[2]]$difference
  ) / iterations

  return(list(
    similarity = similarity,
    bootstrap_results = bootstrap_results,
    significance = significance
  ))
}
```
<br>

```{r Genomic analysis results}
results <- perform_genomic_analysis(binary_matrix)

similarity <- results$similarity
bootstrap_results <- results$bootstrap_results
significance <- results$significance
```
<br>

```{r Plot the bootstrap distribution of differences}
bootstrap_plot <- bootstrap_results %>%
  ggplot(aes(x = difference)) +
  geom_histogram(
    binwidth = 0.001,
    fill = "#7C8DA2"
  ) +
  geom_vline(
    xintercept = similarity[[2]]$difference,
    linetype = "dashed",
    color = "#D09384"
  ) +
  scale_y_continuous(breaks = seq(0, 600, 100)) +
  annotate("text",
    x = similarity[[2]]$difference + 0.012,
    y = 550,
    label = "Observed difference",
    color = "#D09384"
  ) +
  annotate("text",
    x = similarity[[2]]$difference + 0.012,
    y = 500,
    label = paste(
      "p =",
      round(significance, 4)
    ),
    color = "#D09384"
  ) +
  xlab("Difference in mean similarity") +
  ylab("Frequency") +
  theme_cowplot() +
  theme(
    legend.position = "none",
    plot.background = element_rect(fill = "white")
  )

bootstrap_plot
```
<br>

```{r Save bootstrap plot}
ggsave("figure_S1.tiff",
  bootstrap_plot,
  path = "Figures",
  device = "tiff",
  width = 10,
  height = 8,
  units = "in"
)
```
<br>

```{r Multidimensional scaling}
perform_mds <- function(.x) {
  # Computes Dice's Similarity Coefficient for all possible replicate pairs.
  # Populates a matrix with these values.
  pwise_simil_matrix <- as.matrix(
    simil(.x,
      method = "Dice",
      by_rows = TRUE,
      upper = TRUE,
      diag = TRUE
    )
  )

  mds_res <- isoMDS(
    as.dist(1.0 - pwise_simil_matrix),
    maxit = 1000
  )

  mds_res <- mds_res$points %>%
    as_tibble() %>%
    rename(
      MDS1 = V1,
      MDS2 = V2
    ) %>%
    mutate(Group = ifelse(grepl("C", rownames(pwise_simil_matrix)),
      yes = "Control",
      no = "Treated"
    ))

  return(mds_res)
}
```
<br>

```{r Multidimensional scaling results}
mds <- perform_mds(binary_matrix)
```
<br>

```{r Multidimensional scaling plot}
mds_plot <- mds %>%
  ggplot(aes(x = MDS1, y = MDS2, color = Group)) +
  # Place a border around points
  geom_point(size = 3) +
  xlab("MDS1") +
  ylab("MDS2") +
  scale_color_manual(values = c("#C4C4C4", "#7C8DA2")) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    legend.title = element_blank()
  )

mds_plot
```
<br>

```{r Save multidimensional scaling plot}
ggsave("figure_S2.tiff",
  mds_plot,
  path = "Figures",
  device = "tiff",
  width = 10,
  height = 8,
  units = "in"
)
```

The bootstrap analysis showed that the vancomycin-adapted lines differ
significantly in their genetic responses relative to the control lines.
However, this analysis does not specify which genes are associated with each 
treatment. To identify these genes, we perform a multivariate logistic
regression with the treatment status (i.e., vancomycin or no vancomycin) as the
outcome and the qualifying gene-level mutations as the predictors. We only
include in our model qualifying mutations that occur in at least three
populations resulting in 446 gene-level mutations. Because there are only
18 outcome events (i.e., populations that evolved under vancomycin selection)
and 446 predictors, we use L1 penalization on model coefficients to avoid
overfitting.

```{r Logistic regression function}
perform_regression <- function(.x, iterations = 1000) {
  regression_df <- .x %>%
    as.data.frame() %>%
    rownames_to_column(var = "treatment") %>%
    # Remove numbers at the end of the population names
    mutate(treatment = str_remove_all(treatment, "\\d")) %>%
    # If the value in the treatment column is T, replace it with 1.
    # Otherwise, replace it with 0
    mutate(treatment = ifelse(treatment == "T", 1, 0)) %>%
    # Remove columns in which the sum of all values is less than 3
    select_if(~ sum(.) >= 3)

  # Multivariate logistic regression routine over 1,000 iterations to select
  # robust non-zero coefficients

  # Detect number of cores and register parallel backend
  cl <- makeCluster(detectCores() - 1)
  registerDoParallel(cl)

  coef_res <- foreach(
    i = 1:iterations,
    .combine = "rbind",
    .packages = c("glmnet")
  ) %dopar% {
    cvfit <- cv.glmnet(
      as.matrix(regression_df[, -1]),
      as.factor(regression_df$treatment),
      family = binomial(link = "probit"),
      gamma = seq(0, 1, 0.1),
      nfolds = 3,
      maxit = 1e7,
      relax = TRUE
    )

    fit_res <- glmnet(
      as.matrix(regression_df[, -1]),
      as.factor(regression_df$treatment),
      family = binomial(link = "probit"),
      lambda = cvfit$relaxed$lambda.min,
      alpha = cvfit$relaxed$gamma.min
    )

    coef_res <- as.matrix(fit_res$beta)

    return(coef_res)
  }

  stopCluster(cl)

  coef_res <- as.data.frame(coef_res)

  coef_res <- coef_res %>%
    rownames_to_column(var = "genes") %>%
    rename(coef = s0)

  # Remove the decimal and number from the end of the gene names
  coef_res$genes <- str_remove_all(coef_res$genes, "\\..*")

  # For each gene, if the coefficient is non-zero less than 200 of the
  # 1,000 iterations, then exclude it.
  idx <- coef_res %>%
    group_by(genes) %>%
    summarize(count = sum(coef != 0)) %>%
    filter(count >= 200) %>%
    pull(genes)

  coef_OR_filtered <- coef_res %>%
    filter(genes %in% idx) %>%
    # Exponentiate the coefficients to obtain the odds ratio
    mutate(OR = exp(coef))

  ## Determine the 95% confidence interval around the mean coefficient and OR
  ## for each gene
  regression_summary <- coef_OR_filtered %>%
    group_by(genes) %>%
    summarize(
      coef_mean = mean(coef),
      coef_SE = sd(coef) / sqrt(n()),
      OR_mean = mean(OR),
      OR_SE = sd(OR) / sqrt(n())
    ) %>%
    mutate(
      coef_lower_CI = coef_mean - (1.96 * coef_SE),
      coef_upper_CI = coef_mean + (1.96 * coef_SE),
      OR_lower_CI = OR_mean - (1.96 * OR_SE),
      OR_upper_CI = OR_mean + (1.96 * OR_SE)
    )

  # Select columns of the regression_df data frame based on the idx vector
  # (i.e., these coefficients were associated with treatment status in at least
  # 200 of the 1,000 iterations)
  coef_matrix <- as.matrix(regression_df[-1][, idx])
  rownames(coef_matrix) <- rownames(.x)

  # Order the columns in the coef_matrix by OR mean and list the
  # treated lines before the controls
  OR_matrix <- coef_matrix[
    c(paste0("T", 1:18), paste0("C", 1:87)),
    order(regression_summary$OR_mean,
      decreasing = TRUE
    )
  ] %>%
    t()

  results <- list(regression_summary, OR_matrix)

  return(results)
}
```
<br>

```{r Perform logistic regression and plot mean model coefficients}
regression_results <- perform_regression(binary_matrix)

regression_summary <- regression_results[[1]]
OR_matrix <- regression_results[[2]]
```
<br>

```{r Function to plot odds ratios and mutation heat map}
generate_OR_heatmap_plot <- function(.x, .y) {
  OR_status <- .x %>%
    mutate(Group = ifelse(OR_mean > 1,
      "greater",
      "lesser"
    ))

  # Create the waterfall plot
  waterfall_plot <- OR_status %>%
    ggplot(
      aes(
        y = factor(genes,
          levels = rev(rownames(.y))
        ),
        x = OR_mean,
        fill = Group
      )
    ) +
    geom_bar(
      stat = "identity",
      width = 0.9
    ) +
    geom_errorbarh(
      aes(
        xmin = OR_lower_CI,
        xmax = OR_upper_CI
      ),
      height = 0.2
    ) +
    ylab("Gene") +
    xlab("Average odds ratio") +
    scale_fill_manual(values = c("#606B91", "#E0E0E0")) +
    theme_cowplot() +
    theme(
      axis.text.y = element_text(
        angle = 0,
        face = "italic"
      ),
      panel.grid.major = element_line(color = "#EBEBEB"),
      plot.margin = margin(
        t = 25.5,
        b = 9
      ),
      legend.position = "none"
    )

  ## Initial data wrangling to prepare the mutation heat map

  # Genes with mean odds ratios greater than 1
  genes_OR_greater <- .x %>%
    filter(OR_mean > 1) %>%
    pull(genes)

  OR_df <- .y %>%
    as.data.frame() %>%
    rownames_to_column(var = "Gene") %>%
    pivot_longer(
      cols = -Gene,
      names_to = "Population",
      values_to = "Mutation"
    ) %>%
    mutate(
      OR_group = ifelse(Gene %in% genes_OR_greater,
        "greater",
        "lesser"
      ),
      Treatment_group = ifelse(grepl("T", Population),
        "Treated",
        "Control"
      ),
      Population = str_remove_all(Population, "\\D")
    )

  heatmap_plot <- OR_df %>%
    ggplot() +
    facet_grid(
      ~ factor(Treatment_group,
        levels = c("Treated", "Control")
      ),
      scales = "free_x",
      space = "free_x",
      labeller = as_labeller(c(
        "Treated" = "Vancomycin-adapted lines",
        "Control" = "Control lines"
      ))
    ) +
    # Apply a grey (#E7E5DF) fill to the tiles with an odds ratio less than 1
    geom_tile(
      aes(
        x = factor(Population,
          levels = c(1:87)
        ),
        y = factor(Gene,
          levels = rev(rownames(.y))
        ),
        fill = Mutation
      ),
      filter(OR_df, OR_group == "lesser"),
      color = "#EBEBEB"
    ) +
    scale_fill_gradient(low = "#FFFFFF", high = "#E0E0E0") +

    # Start a new scale
    new_scale_fill() +

    # Apply a blue (#606B91) fill to the tiles with an odds ratio greater
    # than 1
    geom_tile(
      aes(
        x = factor(Population,
          levels = c(1:87)
        ),
        y = factor(Gene,
          levels = rev(rownames(.y))
        ),
        fill = Mutation
      ),
      filter(OR_df, OR_group == "greater"),
      color = "#EBEBEB"
    ) +
    scale_fill_gradient(low = "#FFFFFF", high = "#606B91") +
    xlab("Population") +
    theme_cowplot() +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      axis.text.y = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )

  combined_plot <- plot_grid(waterfall_plot,
    heatmap_plot,
    nrow = 1,
    ncol = 2,
    rel_widths = c(0.25, 1)
  ) +
    theme(plot.background = element_rect(fill = "white"))

  return(combined_plot)
}
```
<br>

```{r}
OR_heatmap_plot <- generate_OR_heatmap_plot(regression_summary, OR_matrix)

OR_heatmap_plot
```
<br>

```{r Save mutation heat map}
ggsave("figure_2.tiff",
  OR_heatmap_plot,
  path = "Figures",
  device = "tiff",
  width = 22,
  height = 5,
  units = "in"
)
```
<br>

```{r Latent class analysis function}
perform_lca <- function(dat) {
  # Filter out the control lines in the input matrix and remove columns
  # (features) in which the sum of all values is less than 3

  mut_mat <- dat[grepl(pattern = "^E", rownames(dat)), ]
  mut_mat <- mut_mat[, colSums(mut_mat) >= 3]

  estimate_blca_res <- function(mut_mat, num_classes) {
    # Subsample the lca_mat matrix by randomly selecting 90% of the rows
    # and 90% of the columns
    local_mut_mat <- mut_mat[
      sample(seq_len(nrow(mut_mat)),
        size = ceiling(nrow(mut_mat) * 0.9),
        replace = FALSE
      ),
      sample(seq_len(ncol(mut_mat)),
        size = ncol(mut_mat) * 0.9,
        replace = FALSE
      )
    ]

    tryCatch(expr = {
      # Main routine of LCA, given number of clusters 2:5 estimates the model
      # parameters and selects the best model based on BIC. Based on the best
      # model Cluster assignments are made and kept track of
      local_blca_res <- map(
        num_classes,
        ~ blca(
          X = local_mut_mat,
          G = .x,
          method = "em",
          restarts = 5,
          start.vals = "across"
        )
      )

      best_k <- which.max(map_dbl(
        local_blca_res,
        ~ .x$BIC
      ))

      best_res <- local_blca_res[[best_k]]

      if ((nrow(best_res$Z) == nrow(local_mut_mat)) &
        is.null(rownames(best_res$Z))) {
        cluster_assign <- setNames(
          map_int(
            1:nrow(best_res$Z),
            ~ which.max(best_res$Z[.x, ])
          ),
          rownames(local_mut_mat)
        )

        return(cluster_assign)
      } else if (!is.null(rownames(best_res$Z))) {
        cluster_assign <- setNames(
          map_int(
            1:nrow(best_res$Z),
            ~ which.max(best_res$Z[.x, ])
          )
          [match(
              map_chr(
                1:nrow(local_mut_mat),
                ~ paste(local_mut_mat[.x, ],
                  collapse = ""
                )
              ),
              table = rownames(best_res$Z)
            )],
          rownames(local_mut_mat)
        )

        return(cluster_assign)
      } else {
        return(NULL)
      }
    }, error = function(cond) {
      return(NULL)
    }, warning = function(cond) {
      return(NULL)
    })
  }

  # Detect number of cores and register parallel backend
  cl <- makeCluster(detectCores() - 1)
  registerDoParallel(cl)

  blca_res_em <- foreach(
    i = 1:1000,
    .packages = c("BayesLCA", "purrr")
  ) %dopar% {
    map(
      2:5,
      ~ estimate_blca_res(mut_mat, .x)
    )
  }

  stopCluster(cl)

  blca_res_em <- discard(blca_res_em, is.null)

  sorted_ids <- sort(reduce(map(blca_res_em, names), union))

  pair_mat <- Matrix(0,
    ncol = length(sorted_ids),
    nrow = length(sorted_ids),
    dimnames = list(sorted_ids, sorted_ids)
  )
  count_mat <- Matrix(0,
    ncol = length(sorted_ids),
    nrow = length(sorted_ids),
    dimnames = list(sorted_ids, sorted_ids)
  )

  for (r in 1:length(blca_res_em)) {
    message(sprintf("Processing Run Index: %d", r))
    local_res <- blca_res_em[[r]]
    local_k <- max(local_res)

    local_clust <- as.matrix(Matrix::Diagonal(n = local_k + 1)[local_res, ])
    local_clust <- local_clust %*% t(local_clust)

    # Reorder
    idx <- match(sorted_ids, table = names(local_res))
    local_clust <- local_clust[idx, idx]
    local_clust[is.na(local_clust)] <- 0
    pair_mat <- pair_mat + local_clust

    local_clust <- as.matrix(Matrix::Diagonal(n = 2)[rep(
      1,
      length(local_res)
    ), ])
    local_clust <- local_clust %*% t(local_clust)
    idx <- match(sorted_ids, table = names(local_res))
    local_clust <- local_clust[idx, idx]
    local_clust[is.na(local_clust)] <- 0
    count_mat <- count_mat + local_clust
  }

  freq_mat <- pair_mat / (count_mat + 1)
  freq_mat <- Matrix::forceSymmetric(freq_mat)
  freq_mat <- as.matrix(freq_mat)

  return(freq_mat)
}
```

```{r Perform latent class analysis}
freq_mat <- perform_lca(coef_matrix)
```
<br>

***

# Collateral responses analysis

Load data

```{r Collateral drug MIC data}
# Data report the MICs of 8 antibiotics -- cefazolin, clindamycin, daptomycin,
# gentamycin, meropenem, nafcillin, trimethoprim-sulfamethoxazole, and
# vancomycin -- on the MSSA ancestral clone ATCC 29213 and evolved
# vancomycin-intermediate populations.

collateral_MICs <- read_csv("data/collateral_drug_MICs.csv",
  show_col_types = FALSE
)
```
<br>

```{r Function that calculates collateral response values, messages = FALSE}
calculate_collateral_responses <- function(.x) {
  # This function takes a data frame of MICs and calculates drug response
  # values for each evolved population relative to the ancestral population.
  ancestor_frame <- .x %>%
    filter(population == "Ancestor")

  evolved_frame <- .x %>%
    filter(population != "Ancestor")

  CR_values <- c()

  # This code chunk iterates through the unique paired_IDs in the
  # evolved_frame and filters the ancestor_frame and evolved_frame for the
  # paired_ID. The MIC values for the ancestor and evolved populations are
  # then used to calculate the collateral response value for each evolved
  # population. The collateral response values are then appended to the
  # CR_values vector.
  for (i in unique(evolved_frame$paired_ID)) {
    ancestor_value <- ancestor_frame %>%
      filter(paired_ID == i) %>%
      pull(MIC)

    evolved_subframe <- evolved_frame %>%
      filter(paired_ID == i)

    for (j in 1:nrow(evolved_subframe)) {
      evolved_value <- evolved_subframe[j, ] %>%
        pull(MIC)

      CR_values <- c(CR_values, log2(evolved_value / ancestor_value))
    }
  }

  # Creates a tibble of collateral response values
  CR_col <- tibble(CR = CR_values)
  CR_df <- bind_cols(evolved_frame, CR_col)

  # Remove paired_ID column
  CR_df <- CR_df %>%
    dplyr::select(-paired_ID)

  return(CR_df)
}
```
<br>

```{r Estimate collateral response values, messages = FALSE}
collateral_responses <- calculate_collateral_responses(collateral_MICs)

head(collateral_responses)
```
<br>

```{r Function that estimates summary stats of CR values, messages = FALSE}
perform_summary_stats <- function(.x) {
  summary_stats <- .x %>%
    group_by(antibiotic, population) %>%
    summarize(
      mean_MIC = mean(MIC),
      mean_CR = mean(CR)
    ) %>%
    filter(antibiotic != "VAN")

  # Create a new column called "state" in the summary_stats data frame.
  # Populate this column with "-1", "0", or " 1" if the mean collateral
  # response value is less than, equal to, or greater than 0.
  summary_stats$state <- ifelse(summary_stats$mean_CR < 0,
    yes = "-1",
    no = ifelse(summary_stats$mean_CR == 0,
      yes = "0",
      no = "1"
    )
  )

  return(summary_stats)
}
```
<br>

```{r Calculate summary statistics of CR values, messages = FALSE}
CR_summary_stats <- perform_summary_stats(collateral_responses)

head(CR_summary_stats)
```
<br>

We used Mann-Whitney U tests to compare the collateral response values of
the evolved populations to the ancestral population for each antibiotic.

```{r Function that performs Mann Whitney U tests}
perform_MW_test <- function(.x, ab) {
  ancestor_df <- .x %>%
    filter(population == "Ancestor" & antibiotic == ab) %>%
    dplyr::select(-replicate, -paired_ID)

  evolved_df <- .x %>%
    filter(population != "Ancestor" & antibiotic == ab) %>%
    group_by(population) %>%
    # Calculate the mean MIC for each evolved population
    summarize(MIC = mean(MIC)) %>%
    # Relabel all entries in the "population" column to "Evolved"
    mutate(population = ifelse(population == "Ancestor",
      yes = "Ancestor",
      no = "Evolved"
    ))

  # Bind the antibiotic_df and ancestor_df objects
  bound_df <- bind_rows(evolved_df, ancestor_df)

  # Perform Mann Whitney U test comparing the MICs of the ancestor and
  # evolved populations
  MW_test <- wilcox.test(MIC ~ population,
    data = bound_df,
    exact = FALSE,
    correct = FALSE,
    alternative = "two.sided"
  )

  return(MW_test)
}
```
<br>

```{r Perform Mann Whitney U tests}
mw_stats <- map(
  unique(collateral_MICs$antibiotic),
  ~ perform_MW_test(collateral_MICs,
    ab = .x
  )
)

names(mw_stats) <- unique(collateral_MICs$antibiotic)

list(mw_stats)
```
<br>

We estimate the populations' probability of exhibiting a partiular drug response
following empiric treatment. We computed this estimate for each antibiotic by
comparing the MIC measurements of the evolved populations to the median MIC.

```{r Function that calculates probability of exhibiting a drug response}
calculate_likelihood <- function(.x) {
  prob_vec <- c()

  # For each antibiotic in the summary_stats data frame, we calculate the
  # median collateral response values using the mean_CR column.
  median_df <- .x %>%
    group_by(antibiotic) %>%
    summarize(median = median(mean_CR))

  # We iterate through the unique antibiotics in the summary_stats
  # data frame and calculates the probability of a population exhibiting a drug
  # response. This probability is defined as the fraction of evolved populations
  # that have a collateral response value that has the same sign as the median
  # collateral response value. The probability of a population exhibiting a drug
  # response is calculated for each antibiotic and stored in the prob_vec vector
  for (i in unique(.x$antibiotic)) {
    L <- 0

    ab_frame <- .x %>%
      filter(antibiotic == i)

    med_CR <- ab_frame %>%
      pull(mean_CR) %>%
      median()

    for (j in ab_frame$mean_CR) {
      if (sign(j) == sign(med_CR)) {
        # We initialize a counter (L) at zero and increment it by a fraction
        # (1 / total number of populations) for each mean_CR value that is in
        # concordance with the median.
        L <- L + (1 / nrow(ab_frame))
      }
    }

    prob_vec <- c(prob_vec, L)
  }

  probability_df <- tibble(
    antibiotic = unique(.x$antibiotic),
    probability = prob_vec
  )

  # Join the median_df and probability_df objects by antibiotic
  df <- median_df %>%
    left_join(probability_df, by = "antibiotic")

  return(df)
}
```
<br>

```{r Calculate population probability of exhibiting a drug response}
likelihood_df <- calculate_likelihood(CR_summary_stats)

head(likelihood_df)
```
<br>

```{r Function to plot collateral responses and likelihoods}
generate_CR_likelihood_plot <- function(.x, .y) {
  # Factor antibiotics by order of decreasing median collateral response
  antibiotic_factor <- .x %>%
    group_by(antibiotic) %>%
    summarize(med = median(mean_CR)) %>%
    arrange(desc(med)) %>%
    pull(antibiotic)

  .x$antibiotic <- factor(.x$antibiotic,
    levels = as.factor(antibiotic_factor)
  )

  CR_boxplot <- .x %>%
    ggplot(aes(
      x = antibiotic,
      y = mean_CR,
      fill = antibiotic
    )) +
    geom_boxplot() +
    geom_jitter(
      shape = 16,
      position = position_jitter(0.2),
      size = 2
    ) +
    xlab("Antibiotic") +
    ylab(expression(
      "Log"[2] ~ "MIC"["evolved"] ~ "-" ~ "Log"[2] ~ "MIC"["ancestor"]
    )) +
    scale_fill_manual(values = c(
      "#D09384", "#E4BDB2", "#F7E8E6", "#FFFFFF",
      "#F3EEF9", "#E3DAF3", "#D4C3EA", "#CAB7E6"
    )) +
    theme_cowplot() +
    theme(
      legend.position = "none",
      plot.background = element_rect(fill = "white")
    )

  likelihood_plot <- .y %>%
    ggplot(aes(
      x = probability,
      y = median
    )) +
    geom_hline(
      yintercept = 0,
      linetype = "dashed"
    ) +
    geom_point(
      size = 5.5,
      fill = c(
        "#E4BDB2", "#F3EEF9", "#D09384", "#CAB7E6",
        "#E3DAF3", "#D4C3EA", "#FFFFFF"
      ),
      pch = 21
    ) +
    # Label each point with its corresponding antibiotic
    geom_text(aes(label = antibiotic),
      hjust = -0.5,
      vjust = -0.5,
      size = 5
    ) +
    scale_x_continuous(
      limits = c(0.5, 1),
      breaks = seq(0.5, 1, 0.1)
    ) +
    scale_y_continuous(
      limits = c(-1, 2),
      breaks = seq(-1, 2, 0.5)
    ) +
    xlab("Likelihood of drug response") +
    ylab(
      expression("Log"[2] ~ "MIC"["evolved"]
      ~ "-" ~ "Log"[2] ~ "MIC"["ancestor"])
    ) +
    theme_cowplot() +
    theme(
      legend.position = "none",
      plot.background = element_rect(fill = "white")
    )

  combined_plot <- plot_grid(CR_boxplot,
    likelihood_plot,
    ncol = 2,
    rel_heights = c(0.5, 0.5),
    labels = c("A", "B"),
    label_size = 16
  )

  return(combined_plot)
}
```
<br>

```{r Plot collateral response values}
CR_likelihood_plot <- generate_CR_likelihood_plot(
  CR_summary_stats,
  likelihood_df
)

CR_likelihood_plot
```
<br>

```{r Save plot of probability of drug response}
ggsave("figure_3.tiff",
  CR_likelihood_plot,
  path = "Figures",
  device = "tiff",
  width = 16,
  height = 8,
  units = "in"
)
```
<br>